## \# 정렬



- 거품 정렬

  - 1회전 (n-1)회 비교 => 가장 큰 값 fix

    2회전 (n-2)회 비교 => 두번째 큰 값 fix

    ....

    (n-1)회전 1회 비교 => (n-1)번째 큰 값 fix

    => **<u>시간 복잡도 - 최선, 평균, 최악 모두 O(n^2)</u>** 

    ​      **공간 복잡도 - O(n)**

  - 장점 : 구현이 간단, 추가 메모리 공간이 불필요, **<u>stable한 정렬</u>**

    단점 : 정렬 상태와 상관 없이 고정 횟수 비교로 비효율



- 선택 정렬

  - 주어진 배열 중 최소값을 찾아 앞으로 배치해주는 방식

    => 한 회전 마다 최대 1번의 swap이 발생한다는 점이 거품 정렬과 다름

  - 1회전 (n-1)회 비교 => 가장 작은 값 fix

    2회전 (n-2)회 비교 => 두번째 작은 값 fix

    ...

    (n-1)회전 1회 비교 => (n-1)번째 작은 값 fix

    => **<u>시간 복잡도 - 최선, 평균, 최악 모두 O(n^2)</u>** 

    ​      **공간 복잡도 - O(n)**

  - 장점 : 구현이 간단, 추가 메모리 공간이 불필요

    단점 : 비효율적, **<u>unstable한 정렬</u>**



- 삽입 정렬

  1. 두 번째 원소부터 그 앞의 원소들과 비교하여 삽입할 위치를 선정

  2. 해당 위치로 원소를 삽입

  3. 마지막 원소까지 반복

     

  - 이미 정렬 상태인 경우 => 바로 앞의 원소와만 1번씩 비교 하므로 O(n)

    역정렬 상태인 경우 => 1 + 2 + ... + (n-1) 회 비교하므로 O(n^2)

    => 시간 복잡도 - 최선 O(n)

    ​                             최악 O(n^2)

    ​     공간 복잡도 - O(n)

  - 장점 : 알고리즘이 간단, 대부분의 원소가 정렬되어 있는 경우 효율적, **<u>stable한 정렬</u>**

    단점 : 평균, 최악 시간 복잡도가 O(n^2)



- 퀵 정렬

  1. 주어진 배열에서 pivot값 선택(첫 번째, 중간, 마지막, 랜덤 => <u>주로 첫번째 값 선택</u>)

  2. 오른쪽(인덱스 j)에서 왼쪽으로 가면서 pivot 보다 작은 수 찾음

  3. 왼쪽(인덱스 i)에서 오른쪽으로 가면서 pivot 보다 큰 수 찾음

  4. `i 번째 수 > j 번째 수` 가 되는 경우 => i번째 수와 pivot을 교환

     2, 3번이 불가능해지는 경우 => 그대로 유지

  5. pivot 왼쪽은 pivot 보다 작은 수, 오른쪽은 pivot 보다 큰 수로 구성

     => 양쪽으로 구역을 나눠 각각의 영역에 대해 1번부터 반복

  

  - pivot 값이 최소나 최대값으로 지정되어 구역이 나눠지지 않는 경우 => 최악 O(n^2)

    평균적으로 O(n*logn)

  - 장점 : 평균적으로 빠름

    단점 : 알고리즘이 복잡, 파티션이 나눠지지 않는 경우 최악, **<u>unstable한 정렬</u>**