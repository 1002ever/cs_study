# \# 기초 알고리즘

 

- 이분 탐색(Binary Search)

  => 탐색 범위를 <u>반으로 좁혀감</u>으로써 탐색하는 방법

  - 순서

    1. 정렬이 필수적

    2. left, right, mid를 설정

       => left ~ right 가 탐색 영역

       ​      mid는 left, right 중간 지점

    3. mid와 찾고자 하는 값과 비교

       ㄱ. **구할 값이 mid 보다 크면** 

       ​		다음 탐색 영역 => mid+1 ~ right

       ㄴ. **구할 값이 mid 보다 작으면** 

       ​		다음 탐색 영역 => left ~ left-1

    4. left > right 가 될 때까지 또는 찾고자 하는 값을 찾을 때까지 반복

       => left > right 가 되면 값을 찾지 못한 것





- Hash Table 구현

  => 알고리즘 풀이 시 

  ​     `브루트 포스` 방식으로는 시간 초과에 빠지는 경우 반드시 필요한 방법

  

  - 구현 시 Tip.

    1. 값을 대상으로 Hash 함수를 통해 key를 얻는 것이 목적

    2. 다른 값인데도 같은 key를 return하는 '충돌 현상'에 대비하여

       Hash Table의 크기는 자료 수 보다 크게 설계할 것





- DFS & BFS

  => 그래프 탐색 알고리즘

  

  - DFS

    => 다음 브랜치로 넘어가기 전에 해당 브랜치를 모두 탐색하는 방법

    ​     **스택**이나 **재귀 함수**를 통해 구현

    

    - 시간 복잡도

      ( 노드 수 = V, 간선 수 = E)

      \- 인접 행렬 : O(V^2)

      \- 인접 리스트 : O(V+E)

      

  - BFS

    => 특정 노드에서 인접한 노드부터 먼저 탐색하는 방법

    ​     **큐**를 통해 구현

    ​     <u>최소 비용, 최단 거리 탐색에 적합</u>

    

    - 시간 복잡도

      => DFS와 동일





- 최장 증가 수열(LIS, Longest Increasing Sequence)

  => 가장 긴 증가하는 부분 수열

  

  - 구현 방법
    1. DP : O(N^2)
    2. Lower Bound : O(N*logN)





- 최소 공통 조상(LCA, Lowest Common Ancestor)

  => <u>두 정점이 만나는 최초 부모 정점</u>을 찾는 알고리즘

  

  - 구현 과정
    1. 두 정점의 depth 확인
    2. 더 얕은 곳의 depth를 기준으로 두 정점의 기준점을 맞춰주기
    3. 부모가 같아질 때까지 올라가보기





- 동적 계획법(DP, Dynamic Programming)

  => 복잡한 문제를 간단한 여러 개의 문제로 나누는 방법

  ​      키 포인트는 **<u>한 가지 문제에 대해서는, 단 한 번만 푸는 것</u>**

  

  - 전제 조건

    1. 작은 문제에서 반복이 발생

    2. 같은 문제는 항상 같은 정답

       => `메모이제이션` 기법 활용

       Tip. Memoization?

       ​		: 한 번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식

       ex) 피보나치 구현

       ​	\- 재귀 => O(N^2)

       ​	\- DP => O(N)





- 비트마스크(BitMask)

  => 집합 요소들의 구성 여부를 표현할 때 유용한 기법

  ex)

  ​	[1,2,3,4,5] => 11111

  ​	[2,3,4,5]    => 11110

  ​	[1,2,5]       => 10011

  ​	[2]             => 00010

  ​	=> **조합**을 다음과 같이 <u>인덱스로 표현</u>이 가능

  

  - 삽입 , 삭제 , 조회 연산 구현

    - 위의 예시에서 4번 위치 삽입 , 삭제 , 조회 연산 ex)

      \- 삽입

      ​	10101 | 1 << 3    =>  11101

      \- 삭제

      ​	11101 & ~1 << 3  => 10101

      \- 조회

      ​	(없을 때)

      ​	10101 & 1 << 3    => 0 

      ​	(있을 때)

      ​	11101 & 1 << 3    => 1000