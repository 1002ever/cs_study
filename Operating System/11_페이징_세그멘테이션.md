## 페이징과 세그멘테이션



##### 등장 배경

- 다중 프로그래밍 시스템에서 <u>병행성이 중요</u>하기 때문에

  메모리에 많은 프로세스를 <u>효율적으로 적재</u>하는 것이 중요

  => ***주기억장치를 동적 분할하는 메모리 관리 작업이 필요***



##### 메모리 관리 기법

1. 연속 메모리 관리

   : 프로그램 전체가 연속적인 메모리 공간에 할당

   - 고정 분할 기법 => 내부 단편화가 발생

     동적 분할 기법 => 외부 단편화가 발생



2. 불연속 메모리 관리

   : 프로그램을 쪼개 불연속적인 주소 공간에 할당

   - 페이지 : 고정 사이즈의 작은 프로세스 조각

   - 프레임 : 페이지 크기와 같은 주기억장치 메모리 조각

   - 단편화 : <u>기억 장치의 빈 공간</u> 또는 <u>자료가 여러 조각으로 나뉘는 현상</u>

   - 세그먼트 : 서로 다른 크기를 가진 논리적 블록

     ​                   => 프로세스를 쪼갠 것



##### 페이징(paging)

- 단순 페이징

  \- 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨

  \- 외부 단편화는 발생하지 않음

  ​	=> `프레임 크기 = 페이지 크기` 이므로

  \- 소량의 내부 단편화 존재

  

- 가상 메모리 페이징

  \- 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요가 없음

     => 필요한 페이지가 있으면 나중에 자동으로 불러들임

  \- 단순 페이징과 마찬가지로 외부 단편화가 발생하지 않음

  \- 복잡한 메모리 관리로 오버헤드가 발생





##### 세그먼테이션(Segmentation)

- 단순 세그먼테이션

  \- 각 프로세스를 서로 다른 크기의 세그먼트들로 쪼갬

  \- 가변 크기이기 때문에 내부 단편화는 없음

  ​	=> <u>메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소</u>

  \- <u>외부 단편화는 있을 수 있음</u>



- 가상 메모리 세그먼테이션

  \- 필요하지 않은 세그먼트는 로드되지 않음

  ​	=> 필요한 세그먼트가 있으면 나중에 자동으로 불러들임

  \- 내부 단편화는 없음

  \- 복잡한 메모리 관리로 오버헤드 발생