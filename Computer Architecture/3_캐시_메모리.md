# \# 캐시 메모리



##### \- 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리

​	ex 1) CPU 코어와 메모리 사이의 병목 현상 완화

​			=> Tip. 보통 CPU에는 캐시 메모리가 2~3개 정도 사용(L1, L2, L3)

​						L1 : CPU 내부에 존재

​						L2 : CPU와 RAM 사이에 존재

​						L3 : 보통 메인보드에 존재한다고 함

​	ex 2) 웹 브라우저 캐시 파일은 하드디스크와 웹페이지 사이의 병목 현상 완화



- 디스크 캐시?

  => 주기억장치와 보조기억장치 사이에 존재하는 캐시



- 캐시 메모리 작동 원리 => ***지역성***

  - 시간 지역성

    for나 while 같이 반복문에 사용되는 조건 변수처럼

    한 번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음

  - 공간 지역성

    A[0], A[1]과 같은 연속 접근 시,

    참조된 데이터 근처에 있는 데이터가 잠시 후 또 참조될 가능성이 높음



- CPU가 요청한 데이터가 캐시에 존재 => `Cache Hit`

  CPU가 요청한 데이터가 캐시에 없음 => `Cache Miss`



- 캐시 미스 케이스

  1. Cold Miss

     해당 메모리 주소를 처음 부르는 케이스

  2. Conflict Miss

     캐시 메모리에 A와 B 데이터를 저장해야 하는데,

     둘을 같은 캐시 메모리 주소에 할당해서 생기는 미스

  3. Capacity Miss

     캐시 메모리의 공간 부족으로 나는 미스

  

  - Tip. 캐시 크기를 키우면 되지 않나?
    - 캐시 접근 속도가 느려짐
    - 전력 소모가 큼



- 구조 및 작동 방식

  - Direct Mapped Cache

    - 가장 기본적인 구조
    - DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식
    - 캐시 메모리는 `태그 필드 + 인덱스 필드 + 데이터 필드`로 구성
    - 간단하고 빠르지만, <u>Conflict Miss가 발생 가능</u>

    

  - Fully Associative Cache

    - 빈 캐시 메모리 존재 시, 마음대로 주소를 저장
    - 매우 간단하지만, 찾을 떄가 문제
    - CAM이라는 특수 메모리 구조를 사용해야 하며, 비쌈

    

  - Set Associative Cache

    - Direct + Fully

    - 특정 행을 지정, 그 행 속에 비어있는 열 아무 곳에나 저장

    - Direct 보다는 검색은 느리지만, 저장이 빠르고

      Fully에 비해 검색은 빠르고, 저장은 느리다