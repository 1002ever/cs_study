## TCP ( 흐름제어 / 혼잡제어 )



##### TCP

- 인터넷은 기본적으로 unreliable  network

  => <u>reliable network를 구현하기 위한 기술이 TCP 통신</u>



##### reliable network 를 구현하기 위한 4가지 과제

1. 손실 : packet이 통신 중 손실될 수 있는 문제
2. 순서 바뀜 : packet의 순서가 통신 중 바뀌는 문제
3. 혼잡 : 네트워크가 혼잡한 문제
4. Overload : 수신 측에 overload 되는 문제



##### 흐름제어 / 혼잡제어란?

- 흐름제어

  - 송신측, 수신측 간 데이터 처리 속도 차이를 해결하기 위한 기법

    (endsystem - endsystem)

  - 수신측이 송신측에 packet을 지나치게 많이 받지 않도록 조절하는 것

    => <u>수신측이 송신측에 자신의 상태를 feedback 하는 것이 필요</u>

- 혼잡제어

  - 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법



##### 데이터 전송 과정

1. 송신측 응용 계층이 `소켓`에 data를 씀

2. data를 segment로 감싸고, 네트워크 계층으로 넘겨줌

3. 수신측 노드로 전송

   => 송신, 수신 양쪽의 버퍼에 data를 저장

4. data를 활용할 application에서 준비가 되면 버퍼에 있는 것을 읽음

   => <u>흐름제어의 핵심은 수신측 버퍼(RWND, Receive WiNDow)가 넘치지 않게 하는 것</u>





#### \# 흐름제어 ( Flow Control )

- 수신측 데이터 처리 속도가 송신측 보다 빠르면 흐름제어가 필요 없음

  but 수신측이 더 느리다면, 수신측 저장 용량이 초과된 상태에서 전송된 데이터는 손실

  ​         => <u>불필요한 데이터 재전송이 필요</u>, 때문에 흐름제어 기능이 필요



##### 	흐름제어 방법

​		ㄱ. Stop and Wait

​			: 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송

​		ㄴ. Sliding Window ( Go Back N ARQ )

​			: 수신측에서 설정한 윈도우 크기 만큼 송신측에서 확인 응답 없이 세그먼트 전송

​				=> 데이터를 동적으로 전송

​			\- 목적 : 전송은 되었지만, ACK를 받지 못한 byte의 숫자를 파악하기 위해 사용되는 프로토콜

​			\- 방식

​				1) 윈도우에 포함되는 모든 패킷을 전송

​				2) 그 패킷의 전달이 확인되는대로 윈도우를 옆으로 옮김

​				3) 그 다음 패킷을 전송

​			\- 특징

​				\* TCP / IP 를 사용하는 모든 호스트들은 송/수신측 1개씩, 총 2개의 윈도우를 가짐

​				\* 호스트들은 실제 데이터를 전송하기 전에 3 way handshaking 을 통해

​              	 <u>수신측 윈도우 크기에 맞춰서 송신측 윈도우 크기를 설정한다</u>





#### \# 혼잡제어 ( Congestion Control )

- 한 라우터에 데이터가 몰리는 경우

  => 자신에게 온 데이터를 모두 처리가 불가능.

  ​      그러면 송신측은 다시 데이터를 재전송

  ​       => 네트워크의 혼잡만 가중

- 위와 같은 네트워크의 혼잡 현상을 방지하거나 제거하는 것이 `혼잡제어`

- 흐름제어가 송신 - 수신 간 전송 속도를 다루는 반면,

  혼잡제어는 호스트 - 라우터를 포함한 더 넓은 관점에서 전송 문제를 다룸



##### 	혼잡제어 방법

​		ㄱ. AIMD ( Additive Increase / Multiplicative Decrease )

​			\- 처음엔 패킷을 하나 보냄

​			\- 문제없이 도착하면 <u>window 크기(단위 시간 내 보내는 패킷 수)</u>를 1씩 증가

​			\- 패킷 전송에 실패하거나 일정 시간 초과 시,

​			  전송 속도를 반으로 줄임

​			\- 초기에는 네트워크에 나중에 진입한 호스트가 불리하지만,

​              시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있음 => ***공평한 방식***

​			\- window 크기가 천천히 증가하기 때문에

​              <u>네트워크가 원할한 상태여도, 높은 대역폭을 사용하지 못하는 단점이 존재</u>



​		ㄴ. Slow Start

​			\- AIMD 와 마찬가지로 처음엔 패킷을 하나 보내면서,

​              각각의 ACK 패킷 마다 window 크기를 1씩 증가

​              <u>but 일정 주기 마다 window 크기를 2배로 증가</u>

​			  => 전송 속도가 AIMD에 비해 **지수 함수 꼴로 증가**

​			\- <u>단, 혼잡 현상 발생 시 window 크기를 1로 줄여버린다</u>

​				=> 이후에는 혼잡 현상이 발생했던 window 크기까지는 지수적으로 증가시키고,

​                      그 이후에는 1씩 증가 시킨다



​		ㄷ. Fast Retransmit ( 빠른 재전송 )

​			\- 수신측에 먼저 도착해야 할 패킷이 도착하지 않는 경우, 패킷 전송 순서가 꼬인 경우

​				=> 네트워크 혼잡을 의심해볼 수 있음

​			\- 수신측은 패킷 순서가 올바르지 않게 전송된 경우,

​              <u>순서에 맞게 온 가장 최근의 패킷 번호를 담아 ACK 패킷을 송신측에 전송</u>

​			  => 수신측에 **같은 번호를 갖는 ACK 패킷**을 3번 받으면,

​                   네트워크 혼잡 상태로 보고 데이터를 재전송하며, window 크기를 줄임



​		ㄹ. Fast Recovery ( 빠른 회복 )

​			\- 혼잡 상태가 되면 window 크기를 1로 줄이는 것이 아니라

​               반으로 줄이고, 선형 증가 시키는 방법

​               => <u>혼잡 상황을 한 번 겪으면, 그 이후 순수한 AIMD 방식으로 전환하는 셈</u>

