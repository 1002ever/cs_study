## Stack vs Queue



#### \# Stack

- 입/출력이 한 곳(방향)으로 제한
- LIFO 구조



##### *용례?*

- 함수의 콜스택
- 문자열 역순 출력
- 연산자 후위표기법
- 등..



##### 구현 시 필요 요소 및 함수

- push()

- pop()

- isEmpty()

- isFull()

- SP(Stack Pointer)  =>  가장 최근 값이 존재하는 곳을 가리킴

  ​                                       다음에 어디에 넣을 지 알아야 하므로





#### \# Queue

- 입/출력을 양쪽 끝(front, rear)으로 제한

- FIFO 구조



##### *용례?*

- 버퍼

- 마구 입력된 것을 처리하지 못하고 있는 상황

  => 입력 순으로 처리해야 공정할 것이므로

- BFS

- 등..



##### 구현 사항

- rear로 원소가 들어오고, front로 원소가 나감
- enQueue()
- deQueue()
- isEmpty()
- isFull()
- front => deQueue() 가 수행되는 위치
- rear => enQueue() 가 수행되는 위치



#### 일반 큐의 단점?

- 큐에 빈 메모리가 있어도,

  <u>rear이 끝에 도달하면</u> 꽉 찼다고 판단할 수 있음

  => 이를 극복한 것이 *원형 큐*



##### \#\# 원형 큐

​	\*\* 특징

1. 배열로 구현

2. 빈 것과 가든 찬 것을 구분하기 위해

   자리 하나를 항상 비워둠

3. (rear + 1) % (배열의 크기) == front

   만족 시 이면 가득 찬 것

4. front == rear

   만족 시 비어있는 것

   => 메모리 공간은 잘 활용, **but 배열이기 때문에 큐의 크기가 제한**

   ​	                                          => 이를 극복한 것이 *연결리스트 큐*

   

##### \#\# 연결리스트 큐

- 크기 제한이 X
- 삽입 / 삭제가 용이



​	\*\* 특징

1. 데이터 추가는 끝 부분인 tail에만
2. 데이터를 꺼내는 건 head에서
3. head == tail 만족 시 빈 큐
4. 꽉 찬 상태는 존재하지 않음